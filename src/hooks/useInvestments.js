import { useState, useEffect } from 'react';
import { 
  collection, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  doc, 
  onSnapshot,
  query,
  where,
  Timestamp,
  getDocs 
} from 'firebase/firestore';
import { db } from '../firebase/config';
import { parseDateYMDToSVMidnightUTC } from '../utils/dateTZ';
import { TRANSACTION_ACCOUNT_DEFAULTS } from '../services/accounts';

export const useInvestments = (userId) => {
  const [purchases, setPurchases] = useState([]);
  const [credits, setCredits] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [autoTxEnabled, setAutoTxEnabled] = useState(true);
  const incomeDefaults = TRANSACTION_ACCOUNT_DEFAULTS.ingreso;
  const PROFIT_ROUTE_VERSION = 'v2';
  const CAPITAL_ROUTE_VERSION = 'v1';
  const AUTO_SOURCE_ROLES = {
    PROFIT: 'investment-profit',
    CAPITAL_RETURN: 'investment-capital-return',
  };

  const normalizeDateToISO = (value) => {
    if (!value) {
      return new Date().toISOString();
    }
    if (value instanceof Date) {
      return value.toISOString();
    }
    if (typeof value === 'string') {
      return parseDateYMDToSVMidnightUTC(value).toISOString();
    }
    return new Date(value).toISOString();
  };

  const recordProfitTransaction = async ({
    amount,
    date,
    description,
    sourceType,
    sourceId,
    existingTransactionId = null,
    fromAccountId = 'ingresos-ganancias-inversion',
    toAccountId = incomeDefaults.to,
  }) => {
    const profitValue = Number(amount) || 0;
    if (!userId || profitValue <= 0) {
      return existingTransactionId || null;
    }

    const nowIso = new Date().toISOString();
    const payload = {
      type: 'ingreso',
      description,
      amount: profitValue,
      category: 'Inversiones',
      userId,
      date: normalizeDateToISO(date),
      fromAccountId,
      toAccountId,
      autoGenerated: true,
      autoSourceType: sourceType,
      autoSourceId: sourceId,
      autoRoutingVersion: PROFIT_ROUTE_VERSION,
      autoSourceRole: AUTO_SOURCE_ROLES.PROFIT,
    };

    if (existingTransactionId) {
      await updateDoc(doc(db, 'transactions', existingTransactionId), {
        ...payload,
        updatedAt: nowIso,
      });
      return existingTransactionId;
    }

    const transactionRef = await addDoc(collection(db, 'transactions'), {
      ...payload,
      createdAt: nowIso,
    });
    return transactionRef.id;
  };

  const deleteProfitTransaction = async (transactionId) => {
    if (!transactionId) return;
    await deleteDoc(doc(db, 'transactions', transactionId));
  };

  const recordCapitalReturnTransaction = async ({
    amount,
    date,
    description,
    sourceType,
    sourceId,
    existingTransactionId = null,
    fromAccountId = 'activos-inversiones-productos',
    toAccountId = 'activos-fondo-inversiones',
  }) => {
    const capitalValue = Number(amount) || 0;
    if (!userId || capitalValue <= 0) {
      return existingTransactionId || null;
    }

    const nowIso = new Date().toISOString();
    const payload = {
      type: 'ingreso',
      description,
      amount: capitalValue,
      category: 'Inversiones',
      userId,
      date: normalizeDateToISO(date),
      fromAccountId,
      toAccountId,
      autoGenerated: true,
      autoSourceType: sourceType,
      autoSourceId: sourceId,
      autoRoutingVersion: CAPITAL_ROUTE_VERSION,
      autoSourceRole: AUTO_SOURCE_ROLES.CAPITAL_RETURN,
    };

    if (existingTransactionId) {
      await updateDoc(doc(db, 'transactions', existingTransactionId), {
        ...payload,
        updatedAt: nowIso,
      });
      return existingTransactionId;
    }

    const transactionRef = await addDoc(collection(db, 'transactions'), {
      ...payload,
      createdAt: nowIso,
    });
    return transactionRef.id;
  };

  const deleteCapitalReturnTransaction = async (transactionId) => {
    if (!transactionId) return;
    await deleteDoc(doc(db, 'transactions', transactionId));
  };

  const findAutoTransactionBySource = async ({ sourceType, sourceId, role = null }) => {
    if (!sourceType || !sourceId) return null;
    const baseCollection = collection(db, 'transactions');
    const filters = [
      where('autoSourceType', '==', sourceType),
      where('autoSourceId', '==', sourceId),
    ];

    const execQuery = async (queryFilters) => {
      const snapshot = await getDocs(query(baseCollection, ...queryFilters));
      if (snapshot.empty) return null;
      const docSnapshot = snapshot.docs[0];
      return { id: docSnapshot.id, data: docSnapshot.data() };
    };

    if (role) {
      const resultWithRole = await execQuery([...filters, where('autoSourceRole', '==', role)]);
      if (resultWithRole) {
        return resultWithRole;
      }
    }

    return execQuery(filters);
  };

  useEffect(() => {
    if (!userId) {
      setPurchases([]);
      setCredits([]);
      setLoading(false);
      return;
    }

    // Suscripción a compras (solo filtro por userId, ordenamiento en cliente)
    const purchasesQuery = query(
      collection(db, 'purchases'),
      where('userId', '==', userId)
    );

    const unsubscribePurchases = onSnapshot(
      purchasesQuery,
      (snapshot) => {
        const purchasesData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          date: doc.data().date?.toDate() || new Date()
        }))
        .sort((a, b) => b.date - a.date); // Ordenar en el cliente
        
        setPurchases(purchasesData);
      },
      (err) => {
        console.error('Error fetching purchases:', err);
        setError(err.message);
      }
    );

    // Suscripción a créditos (solo filtro por userId, ordenamiento en cliente)
    const creditsQuery = query(
      collection(db, 'credits'),
      where('userId', '==', userId)
    );

    const unsubscribeCredits = onSnapshot(
      creditsQuery,
      (snapshot) => {
        const creditsData = snapshot.docs.map(doc => {
          const data = doc.data();
          return {
            id: doc.id,
            ...data,
            date: data.date?.toDate() || new Date(),
            // Convertir fechas de pagos de Timestamp a Date
            payments: (data.payments || []).map(payment => ({
              ...payment,
              date: payment.date?.toDate ? payment.date.toDate() : new Date(payment.date),
              createdAt: payment.createdAt?.toDate ? payment.createdAt.toDate() : new Date()
            }))
          };
        })
        .sort((a, b) => b.date - a.date); // Ordenar en el cliente
        
        setCredits(creditsData);
        setLoading(false);
      },
      (err) => {
        console.error('Error fetching credits:', err);
        setError(err.message);
        setLoading(false);
      }
    );

    return () => {
      unsubscribePurchases();
      unsubscribeCredits();
    };
  }, [userId]);

  useEffect(() => {
    if (!userId || purchases.length === 0) return;

    const migratePurchases = async () => {
      if (!autoTxEnabled) return;
      const pending = purchases.filter(
        (purchase) => purchase.profit > 0 && purchase.profitRouteVersion !== PROFIT_ROUTE_VERSION
      );

      for (const purchase of pending) {
        try {
          let existingTransactionId = purchase.profitTransactionId;
          if (!existingTransactionId) {
            const existingTx = await findAutoTransactionBySource({
              sourceType: 'purchase',
              sourceId: purchase.id,
              role: AUTO_SOURCE_ROLES.PROFIT,
            });
            existingTransactionId = existingTx?.id || null;
          }
          const profitTransactionId = await recordProfitTransaction({
            amount: purchase.profit,
            date: purchase.date,
            description: `Ganancia por compra: ${purchase.productName || purchase.description || 'Compra'}`,
            sourceType: 'purchase',
            sourceId: purchase.id,
            existingTransactionId,
            fromAccountId: 'ingresos-ganancias-inversion',
            toAccountId: 'activos-banco',
          });

          await updateDoc(doc(db, 'purchases', purchase.id), {
            profitTransactionId,
            profitRouteVersion: PROFIT_ROUTE_VERSION,
          });
        } catch (migrationError) {
          if (migrationError.code === 'permission-denied') {
            setAutoTxEnabled(false);
            break;
          }
          console.warn('Error migrating purchase profit transaction:', migrationError);
        }
      }
    };

    migratePurchases();
  }, [purchases, userId, autoTxEnabled]);

  useEffect(() => {
    if (!userId || purchases.length === 0) return;

    const migrateCapitalReturns = async () => {
      if (!autoTxEnabled) return;
      const pending = purchases.filter(
        (purchase) => (purchase.investment || 0) > 0 && purchase.capitalRouteVersion !== CAPITAL_ROUTE_VERSION
      );

      for (const purchase of pending) {
        try {
          let existingTransactionId = purchase.capitalReturnTransactionId;
          if (!existingTransactionId) {
            const existingTx = await findAutoTransactionBySource({
              sourceType: 'purchase',
              sourceId: purchase.id,
              role: AUTO_SOURCE_ROLES.CAPITAL_RETURN,
            });
            existingTransactionId = existingTx?.id || null;
          }

          const investmentAmount = Number(purchase.investment) || 0;
          if (investmentAmount > 0) {
            const capitalReturnTransactionId = await recordCapitalReturnTransaction({
              amount: investmentAmount,
              date: purchase.date,
              description: `Devolución de capital: ${purchase.productName || purchase.description || 'Compra'}`,
              sourceType: 'purchase',
              sourceId: purchase.id,
              existingTransactionId,
            });

            await updateDoc(doc(db, 'purchases', purchase.id), {
              capitalReturnTransactionId,
              capitalRouteVersion: capitalReturnTransactionId ? CAPITAL_ROUTE_VERSION : null,
            });
          } else if (existingTransactionId) {
            await deleteCapitalReturnTransaction(existingTransactionId);
            await updateDoc(doc(db, 'purchases', purchase.id), {
              capitalReturnTransactionId: null,
              capitalRouteVersion: null,
            });
          }
        } catch (migrationError) {
          if (migrationError.code === 'permission-denied') {
            setAutoTxEnabled(false);
            break;
          }
          console.warn('Error migrating purchase capital return transaction:', migrationError);
        }
      }
    };

    migrateCapitalReturns();
  }, [purchases, userId, autoTxEnabled]);

  useEffect(() => {
    if (!userId || credits.length === 0) return;

    const migrateCredits = async () => {
      if (!autoTxEnabled) return;
      const pending = credits.filter(
        (credit) => credit.interestAmount > 0 && credit.interestRouteVersion !== PROFIT_ROUTE_VERSION
      );

      for (const credit of pending) {
        try {
          let existingTransactionId = credit.interestTransactionId;
          if (!existingTransactionId) {
            const existingTx = await findAutoTransactionBySource({
              sourceType: 'credit',
              sourceId: credit.id,
              role: AUTO_SOURCE_ROLES.PROFIT,
            });
            existingTransactionId = existingTx?.id || null;
          }
          const interestTransactionId = await recordProfitTransaction({
            amount: credit.interestAmount,
            date: credit.date,
            description: `Ganancia por crédito: ${credit.clientName || 'Crédito'}`,
            sourceType: 'credit',
            sourceId: credit.id,
            existingTransactionId,
			fromAccountId: 'ingresos-intereses',
            toAccountId: 'activos-banco',
          });

          await updateDoc(doc(db, 'credits', credit.id), {
            interestTransactionId,
            interestRouteVersion: PROFIT_ROUTE_VERSION,
          });
        } catch (migrationError) {
          if (migrationError.code === 'permission-denied') {
            setAutoTxEnabled(false);
            break;
          }
          console.warn('Error migrating credit profit transaction:', migrationError);
        }
      }
    };

    migrateCredits();
  }, [credits, userId, autoTxEnabled]);

  // Agregar compra
  const addPurchase = async (purchaseData) => {
    try {
      const normalizedDate = parseDateYMDToSVMidnightUTC(purchaseData.date);
      const newPurchase = {
        ...purchaseData,
        userId,
        date: Timestamp.fromDate(normalizedDate),
        profit: purchaseData.salePrice - purchaseData.investment,
        roi: ((purchaseData.salePrice - purchaseData.investment) / purchaseData.investment) * 100,
        createdAt: Timestamp.now(),
        profitRouteVersion: PROFIT_ROUTE_VERSION,
        capitalRouteVersion: null,
      };

      const purchaseRef = await addDoc(collection(db, 'purchases'), newPurchase);
      const purchaseUpdates = {};

      if (newPurchase.profit > 0) {
        const profitTransactionId = await recordProfitTransaction({
          amount: newPurchase.profit,
          date: purchaseData.date,
          description: `Ganancia por compra: ${purchaseData.productName}`,
          sourceType: 'purchase',
          sourceId: purchaseRef.id,
          fromAccountId: 'ingresos-ganancias-inversion',
          toAccountId: 'activos-banco',
        });

        if (profitTransactionId) {
          purchaseUpdates.profitTransactionId = profitTransactionId;
          purchaseUpdates.profitRouteVersion = PROFIT_ROUTE_VERSION;
        }
      }

      if (newPurchase.investment > 0) {
        const capitalReturnTransactionId = await recordCapitalReturnTransaction({
          amount: newPurchase.investment,
          date: purchaseData.date,
          description: `Devolución de capital: ${purchaseData.productName}`,
          sourceType: 'purchase',
          sourceId: purchaseRef.id,
        });

        if (capitalReturnTransactionId) {
          purchaseUpdates.capitalReturnTransactionId = capitalReturnTransactionId;
          purchaseUpdates.capitalRouteVersion = CAPITAL_ROUTE_VERSION;
        }
      }

      if (Object.keys(purchaseUpdates).length > 0) {
        await updateDoc(purchaseRef, purchaseUpdates);
      }

      return { success: true };
    } catch (err) {
      console.error('Error adding purchase:', err);
      return { success: false, error: err.message };
    }
  };

  // Actualizar compra
  const updatePurchase = async (purchaseId, purchaseData) => {
    try {
      const purchaseRef = doc(db, 'purchases', purchaseId);
      const existingPurchase = purchases.find(p => p.id === purchaseId);
      const normalizedDate = purchaseData.date instanceof Date
          ? purchaseData.date
          : parseDateYMDToSVMidnightUTC(purchaseData.date);
      const profitValue = purchaseData.salePrice - purchaseData.investment;
      let profitTransactionId = existingPurchase?.profitTransactionId || null;
      let capitalReturnTransactionId = existingPurchase?.capitalReturnTransactionId || null;
      const investmentValue = Number(purchaseData.investment) || 0;

      if (profitValue > 0) {
        profitTransactionId = await recordProfitTransaction({
          amount: profitValue,
          date: purchaseData.date,
          description: `Ganancia por compra: ${purchaseData.productName}`,
          sourceType: 'purchase',
          sourceId: purchaseId,
          existingTransactionId: profitTransactionId,
          fromAccountId: 'ingresos-ganancias-inversion',
          toAccountId: 'activos-banco',
        });
      } else if (profitTransactionId) {
        await deleteProfitTransaction(profitTransactionId);
        profitTransactionId = null;
      }

      if (investmentValue > 0) {
        capitalReturnTransactionId = await recordCapitalReturnTransaction({
          amount: investmentValue,
          date: purchaseData.date,
          description: `Devolución de capital: ${purchaseData.productName}`,
          sourceType: 'purchase',
          sourceId: purchaseId,
          existingTransactionId: capitalReturnTransactionId,
        });
      } else if (capitalReturnTransactionId) {
        await deleteCapitalReturnTransaction(capitalReturnTransactionId);
        capitalReturnTransactionId = null;
      }

      const updatedData = {
        ...purchaseData,
        date: Timestamp.fromDate(normalizedDate),
        profit: profitValue,
        roi: ((purchaseData.salePrice - purchaseData.investment) / purchaseData.investment) * 100,
        updatedAt: Timestamp.now(),
        profitTransactionId: profitTransactionId || null,
        profitRouteVersion: profitTransactionId ? PROFIT_ROUTE_VERSION : null,
        capitalReturnTransactionId: capitalReturnTransactionId || null,
        capitalRouteVersion: capitalReturnTransactionId ? CAPITAL_ROUTE_VERSION : null,
      };

      await updateDoc(purchaseRef, updatedData);
      return { success: true };
    } catch (err) {
      console.error('Error updating purchase:', err);
      return { success: false, error: err.message };
    }
  };

  // Eliminar compra
  const deletePurchase = async (purchaseId) => {
    try {
      const purchase = purchases.find(p => p.id === purchaseId);
      if (purchase?.profitTransactionId) {
        await deleteProfitTransaction(purchase.profitTransactionId);
      }
      if (purchase?.capitalReturnTransactionId) {
        await deleteCapitalReturnTransaction(purchase.capitalReturnTransactionId);
      }
      await deleteDoc(doc(db, 'purchases', purchaseId));
      return { success: true };
    } catch (err) {
      console.error('Error deleting purchase:', err);
      return { success: false, error: err.message };
    }
  };

  // Agregar crédito
  const addCredit = async (creditData) => {
    try {
      const normalizedDate = parseDateYMDToSVMidnightUTC(creditData.date);
      const newCredit = {
        ...creditData,
        userId,
        date: Timestamp.fromDate(normalizedDate),
        payments: [],
        totalPaid: 0,
        remainingBalance: creditData.totalAmount,
        status: 'active',
        createdAt: Timestamp.now(),
        interestRouteVersion: creditData.interestAmount > 0 ? PROFIT_ROUTE_VERSION : null,
      };

      await addDoc(collection(db, 'credits'), newCredit);
      return { success: true };
    } catch (err) {
      console.error('Error adding credit:', err);
      return { success: false, error: err.message };
    }
  };

  // Actualizar crédito
  const updateCredit = async (creditId, creditData) => {
    try {
      const creditRef = doc(db, 'credits', creditId);
      const existingCredit = credits.find(c => c.id === creditId);
      const normalizedDate = creditData.date instanceof Date
          ? creditData.date
          : parseDateYMDToSVMidnightUTC(creditData.date);

      let interestTransactionId = existingCredit?.interestTransactionId || null;
      const creditIsCompleted = existingCredit?.status === 'completed';
      if (creditIsCompleted && creditData.interestAmount > 0) {
        interestTransactionId = await recordProfitTransaction({
          amount: creditData.interestAmount,
          date: creditData.date,
          description: `Ganancia por crédito: ${creditData.clientName}`,
          sourceType: 'credit',
          sourceId: creditId,
          existingTransactionId: interestTransactionId,
          fromAccountId: 'ingresos-intereses',
          toAccountId: 'activos-banco',
        });
      } else if (interestTransactionId && !creditIsCompleted) {
        await deleteProfitTransaction(interestTransactionId);
        interestTransactionId = null;
      }

      let updatedData = {
        ...creditData,
        date: Timestamp.fromDate(normalizedDate),
        updatedAt: Timestamp.now(),
        interestTransactionId: interestTransactionId || null,
        interestRouteVersion: interestTransactionId ? PROFIT_ROUTE_VERSION : null,
      };

      await updateDoc(creditRef, updatedData);
      return { success: true };
    } catch (err) {
      console.error('Error updating credit:', err);
      return { success: false, error: err.message };
    }
  };

  // Agregar pago a un crédito
  const addPayment = async (creditId, paymentAmount, paymentDate = new Date(), notes = '') => {
    try {
      const credit = credits.find(c => c.id === creditId);
      if (!credit) throw new Error('Credit not found');

      const parsedPaymentDate = paymentDate instanceof Date ? paymentDate : parseDateYMDToSVMidnightUTC(paymentDate);

      const newPayment = {
        amount: parseFloat(paymentAmount),
        date: Timestamp.fromDate(parsedPaymentDate),
        notes: notes,
        createdAt: Timestamp.now()
      };

      const updatedPayments = [...(credit.payments || []), newPayment];
      const totalPaid = updatedPayments.reduce((sum, p) => sum + p.amount, 0);
      const remainingBalance = credit.totalAmount - totalPaid;
      const status = remainingBalance <= 0 ? 'completed' : 'active';

      const creditRef = doc(db, 'credits', creditId);
      let interestTransactionId = credit.interestTransactionId || null;
      if (status === 'completed' && credit.interestAmount > 0) {
        interestTransactionId = await recordProfitTransaction({
          amount: credit.interestAmount,
          date: parsedPaymentDate,
          description: `Ganancia por crédito: ${credit.clientName}`,
          sourceType: 'credit',
          sourceId: creditId,
          existingTransactionId: interestTransactionId,
          fromAccountId: 'ingresos-intereses',
          toAccountId: 'activos-banco',
        });
      } else if (interestTransactionId && status !== 'completed') {
        await deleteProfitTransaction(interestTransactionId);
        interestTransactionId = null;
      }

      await updateDoc(creditRef, {
        payments: updatedPayments,
        totalPaid,
        remainingBalance: Math.max(0, remainingBalance),
        status,
        updatedAt: Timestamp.now(),
        interestTransactionId: interestTransactionId || null,
        interestRouteVersion: interestTransactionId ? PROFIT_ROUTE_VERSION : credit.interestRouteVersion || null,
      });

      return { success: true };
    } catch (err) {
      console.error('Error adding payment:', err);
      return { success: false, error: err.message };
    }
  };

  // Eliminar pago de un crédito
  const deletePayment = async (creditId, paymentIndex) => {
    try {
      const credit = credits.find(c => c.id === creditId);
      if (!credit) throw new Error('Credit not found');

      const updatedPayments = credit.payments.filter((_, index) => index !== paymentIndex);
      const totalPaid = updatedPayments.reduce((sum, p) => sum + p.amount, 0);
      const remainingBalance = credit.totalAmount - totalPaid;
      const status = remainingBalance <= 0 ? 'completed' : 'active';

      const creditRef = doc(db, 'credits', creditId);
      let interestTransactionId = credit.interestTransactionId || null;
      if (status === 'completed' && credit.interestAmount > 0) {
        interestTransactionId = await recordProfitTransaction({
          amount: credit.interestAmount,
          date: credit.date,
          description: `Ganancia por crédito: ${credit.clientName}`,
          sourceType: 'credit',
          sourceId: creditId,
          existingTransactionId: interestTransactionId,
          fromAccountId: 'ingresos-intereses',
          toAccountId: 'activos-banco',
        });
      } else if (interestTransactionId && status !== 'completed') {
        await deleteProfitTransaction(interestTransactionId);
        interestTransactionId = null;
      }

      await updateDoc(creditRef, {
        payments: updatedPayments,
        totalPaid,
        remainingBalance: Math.max(0, remainingBalance),
        status,
        updatedAt: Timestamp.now(),
        interestTransactionId: interestTransactionId || null,
        interestRouteVersion: interestTransactionId ? PROFIT_ROUTE_VERSION : credit.interestRouteVersion || null,
      });

      return { success: true };
    } catch (err) {
      console.error('Error deleting payment:', err);
      return { success: false, error: err.message };
    }
  };

  // Eliminar crédito
  const deleteCredit = async (creditId) => {
    try {
      const credit = credits.find(c => c.id === creditId);
      if (credit?.interestTransactionId) {
        await deleteProfitTransaction(credit.interestTransactionId);
      }
      await deleteDoc(doc(db, 'credits', creditId));
      return { success: true };
    } catch (err) {
      console.error('Error deleting credit:', err);
      return { success: false, error: err.message };
    }
  };

  return {
    purchases,
    credits,
    loading,
    error,
    addPurchase,
    updatePurchase,
    deletePurchase,
    addCredit,
    updateCredit,
    deleteCredit,
    addPayment,
    deletePayment
  };
};
